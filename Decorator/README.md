# Decorator

## 动机（Motivation）
+ 在某些情况下我们可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性；
并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。
+ 如何使“对象功能的扩展”能够根据需要来动态地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响将为最低？

## 模式定义
动态（组合）地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码 & 减少子类个数）。
——《设计模式》GoF


## 主要解决：
扩展功能的组合导致子类急剧增加的场景

## 何时使用：
+ 增加职责：
当需要给对象动态地添加职责时，装饰模式提供了一种灵活的解决方案。

+ 扩展类的功能：
当类的功能需要扩展，但又不想用继承的方式时，可以使用装饰模式。

+ 动态行为：
如果需要在运行时动态地给对象添加行为，装饰模式可以轻松实现。

+ 透明性：
装饰模式可以保持对客户端的透明性，即客户端无需知道对象是原始对象还是被装饰过的对象。

+ 灵活性：
装饰模式可以很容易地通过添加新的装饰者类来扩展系统的功能。


## 如何使用：
+ 首先，定义抽象构件：
```
class Stream{

public:
    virtual char Read(int number)=0;
    virtual void Seek(int position)=0;
    virtual void Write(char data)=0;
    
    virtual ~Stream(){}
};

```

+ 接着，创建具体构件：
```
class FileStream: public Stream{
public:
    virtual char Read(int number){
        //读文件流
    }
    virtual void Seek(int position){
        //定位文件流
    }
    virtual void Write(char data){
        //写文件流
    }

};
```
+ 定义抽象装饰者：
```
DecoratorStream: public Stream{
protected:
    Stream* stream;//...
    
    DecoratorStream(Stream * stm):stream(stm){
    
    }
    
};
```
+ 创建具体装饰者:
```
class CryptoStream: public DecoratorStream {
 

public:
    CryptoStream(Stream* stm):DecoratorStream(stm){
    
    }
    
    
    virtual char Read(int number){
       
        //额外的加密操作...
        stream->Read(number);//读文件流
    }
    virtual void Seek(int position){
        //额外的加密操作...
        stream::Seek(position);//定位文件流
        //额外的加密操作...
    }
    virtual void Write(byte data){
        //额外的加密操作...
        stream::Write(data);//写文件流
        //额外的加密操作...
    }
};
```

+ 客户端代码使用装饰模式
```
void Process(){

    //运行时装配
    FileStream* s1=new FileStream();
    
    CryptoStream* s2=new CryptoStream(s1);
    
    BufferedStream* s3=new BufferedStream(s1);
    
    BufferedStream* s4=new BufferedStream(s2);

}
```

## 代码结构：
具有构件抽象和装饰抽象两个抽象类，装饰抽象类中包含构件抽象类，通过基类组合来实现功能的组合

## 扩展方式
通过继承装饰抽象或者构件抽象来进行组合功能的扩展


## 装饰模式的应用场景
+ 增加职责：
当需要给对象动态地添加职责时，装饰模式提供了一种灵活的解决方案。

+ 扩展类的功能：
当类的功能需要扩展，但又不想用继承的方式时，可以使用装饰模式。

+ 动态行为：
如果需要在运行时动态地给对象添加行为，装饰模式可以轻松实现。

+ 透明性：
装饰模式可以保持对客户端的透明性，即客户端无需知道对象是原始对象还是被装饰过的对象。

+ 灵活性：
装饰模式可以很容易地通过添加新的装饰者类来扩展系统的功能。
1、GUI组件功能增强：
在图形用户界面（GUI）编程中，可以为按钮、文本框等组件动态添加如边框、颜色、工具提示等额外功能。

2、日志记录和事务处理：
在需要对方法执行进行日志记录或事务处理的场景中，装饰模式可以动态地为方法调用添加日志记录或事务管理功能。

3、性能监测：
在应用程序中，可以使用装饰模式为方法添加性能监测功能，以统计方法的执行时间。

4、缓存机制：
在需要缓存结果以提高性能的场景中，装饰模式可以为对象添加缓存功能。

5、安全性控制：
在需要对资源访问进行权限检查的场景中，装饰模式可以为方法或对象添加安全性控制。

6、网络通信：
在网络编程中，装饰模式可以用于添加如压缩、加密、身份验证等网络通信的功能。

7、资源管理：
在资源管理场景中，如文件操作或数据库操作，装饰模式可以用于添加资源的打开、关闭以及资源使用监控等功能。

8、原型模式的扩展：
与原型模式结合使用，可以创建具有新行为的深拷贝对象。

9、实现策略模式的备用方案：
当需要在运行时动态改变对象的行为时，装饰模式可以作为策略模式的替代方案。

10、实现开闭原则：
在需要遵循开闭原则（对扩展开放，对修改关闭）的场景中，装饰模式允许在不修改现有代码的基础上扩展功能。

11、实现享元模式：
与享元模式结合使用，装饰模式可以用于实现共享对象的特定行为。

12、中间件开发：
在开发中间件时，装饰模式可以用于动态地添加或替换中间件组件的功能。

13、Web开发：
在Web开发中，装饰模式可以用于动态地为Web页面元素添加样式、脚本或其他行为。

14、游戏开发：
在游戏开发中，装饰模式可以用于为游戏对象添加如动画效果、特殊能力等额外功能。


## 装饰模式优缺点
+ 优点
1、你无需创建新子类即可扩展对象的行为。
2、你可以在运行时添加或删除对象的功能。
3、你可以用多个装饰封装对象来组合几种行为。
4、单一职责原则。 你可以将实现了许多不同行为的一个大类拆分为多个较小的类。
+ 缺点
1、在封装器栈中删除特定封装器比较困难。
2、实现行为不受装饰栈顺序影响的装饰比较困难。
3、各层的初始化配置代码看上去可能会很糟糕。


## 在实际开发中，如何决定何时使用装饰模式而不是其他设计模式？
在实际开发中，决定何时使用装饰模式（Decorator Pattern）而不是其他设计模式，可以根据以下几个关键点来考虑：

动态扩展功能：

如果需要在运行时动态地给对象添加额外的职责或行为，装饰模式是一个合适的选择。
透明性：

装饰模式可以保持对客户端的透明性，即客户端无需知道对象是原始对象还是被装饰过的对象。如果需要保持接口的一致性，可以考虑使用装饰模式。
灵活性和可扩展性：

如果系统需要高度的灵活性和可扩展性，装饰模式允许你通过添加新的装饰者类来扩展功能，而不是通过修改现有代码。
避免类爆炸：

当使用继承来扩展功能时，可能会导致类的数量急剧增加（类爆炸）。装饰模式通过组合来扩展功能，可以减少类的数目。
单一职责原则：

如果希望遵循单一职责原则，避免在一个类中包含多个功能，可以使用装饰模式将不同的功能分离到不同的装饰者类中。
与继承的比较：

继承是一种静态的行为扩展方式，而装饰模式提供了一种动态的扩展方式。如果行为扩展是已知的且固定的，继承可能是更好的选择；如果行为扩展是动态的或不确定的，装饰模式更合适。
组合优于继承：

如果遵循“组合优于继承”的设计原则，装饰模式通过组合来实现功能的扩展，而不是通过继承。
开闭原则：

如果希望系统对扩展开放，对修改关闭，装饰模式允许在不修改现有代码的基础上扩展功能。
避免多层继承：

如果使用继承会导致多层继承结构，这可能会使系统难以理解和维护。装饰模式可以避免这种情况，因为它通过组合来实现功能的扩展。
实现策略模式的替代方案：

当需要在运行时动态改变对象的行为时，装饰模式可以作为策略模式的替代方案。
性能考虑：

如果性能是一个关键因素，需要考虑装饰模式可能会引入的额外开销。在某些情况下，使用继承或其他模式可能更高效。
团队熟悉度：

考虑团队对不同设计模式的熟悉度和使用经验，选择团队更熟悉和更易于维护的模式。
在决定使用装饰模式时，需要权衡上述因素，并根据具体的应用场景和设计需求来做出选择。装饰模式特别适合于需要动态、灵活地扩展对象功能的情况。

## 装饰模式有什么问题？
装饰模式在实际开发中可能会遇到以下常见问题：

复杂性增加：

装饰模式可能会导致系统中存在大量的装饰器类，特别是当有多个层次的装饰时。这可能会使得系统结构变得复杂，难以理解和维护。为了解决这个问题，应该只在确实需要的时候添加装饰器，并且保持装饰器的职责单一。
性能问题：

装饰模式通过包装对象来添加功能，这可能会导致性能上的开销，尤其是在装饰链很长的情况下。为了减少性能影响，应该优化装饰器的实现，避免不必要的包装，并且在设计时考虑性能。
过度使用：

如果不加限制地使用装饰模式，可能会导致装饰器类的数量急剧膨胀，这与设计模式的初衷相违背。应该在设计时仔细考虑是否真的需要装饰器来提供额外的功能。
装饰顺序敏感：

在某些情况下，装饰器的执行顺序可能会影响对象的行为。这可能会导致难以预测的结果。为了解决这个问题，可以通过明确的顺序约定或者在设计时就考虑到执行顺序的影响。
难以管理装饰链：

在复杂的系统中，维护一个清晰的装饰链可能会很困难。可以通过引入更多的结构化管理或者使用设计模式如工厂模式来创建和管理装饰链。
装饰器的透明性：

装饰器应该对客户端透明，这意味着客户端代码应该能够在不知道具体装饰器的情况下使用装饰后的对象。如果装饰器的实现不够透明，可能会导致客户端代码需要针对不同的装饰器编写不同的逻辑。
装饰器的复用性：

装饰器应该具有良好的复用性，以便可以在不同的上下文中重复使用。如果装饰器与特定的组件紧密耦合，可能会降低其复用性。
为了克服这些问题，应该在设计时仔细考虑装饰模式的应用场景，并且在实现时注意保持装饰器的简洁和透明性。同时，也应该考虑到系统的可维护性和性能。在需要动态扩展功能时，装饰模式是一种有效的设计模式，但应该谨慎使用，避免上述问题的出现。


## 要点总结
+ 通过采用组合而非继承的手法， Decorator模式实现了在运行时动态扩展对象功能的能力，而且可以根据需要扩展多个功能。
避免了使用继承带来的“灵活性差”和“多子类衍生问题”。
+ Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。
但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。
+ Decorator模式的目的并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。
